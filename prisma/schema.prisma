generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ===== АВТОРИЗАЦИЯ (NextAuth) =====

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// ===== ПОЛЬЗОВАТЕЛИ =====

model User {
  id             String    @id @default(cuid())
  name           String?
  email          String?   @unique
  emailVerified  DateTime?
  image          String?
  role           Role      @default(EMPLOYEE)
  canLogin       Boolean   @default(false)
  telegramChatId String?
  notifyEmail    Boolean   @default(true)
  notifyTelegram Boolean   @default(false)
  notifySms      Boolean   @default(false)
  notifyInApp    Boolean   @default(true)
  quietHoursStart String?
  quietHoursEnd   String?
  digestFrequency DigestFrequency @default(NONE)
  tokenVersion   Int       @default(0) // Инкрементируется для инвалидации JWT токенов
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  lastLoginAt    DateTime?

  accounts        Account[]
  sessions        Session[]
  letters         Letter[]        @relation("OwnerLetters")
  comments        Comment[]
  watchers        Watcher[]
  favorites       Favorite[]
  history         History[]
  answerTemplates AnswerTemplate[]
  letterTemplates LetterTemplate[] @relation("LetterTemplateCreator")
  notifications   Notification[]
  profile         UserProfile?
  auditsTarget    UserAudit[]     @relation("UserAuditTarget")
  auditsActor     UserAudit[]     @relation("UserAuditActor")
  loginAudits     LoginAudit[]
  approvalsTarget AdminApproval[] @relation("AdminApprovalTarget")
  approvalsRequested AdminApproval[] @relation("AdminApprovalRequestedBy")
  approvalsApproved AdminApproval[] @relation("AdminApprovalApprovedBy")
  requestsAssigned   Request[]        @relation("RequestAssignee")
  requestComments    RequestComment[] @relation("RequestCommentAuthor")
  requestHistory     RequestHistory[] @relation("RequestHistoryActor")
  pushSubscriptions  PushSubscription[]
  requestTemplates   RequestResponseTemplate[]
  preferences        UserPreferences?

  @@index([role])              // Индекс для фильтрации по роли
  @@index([canLogin])          // Индекс для фильтрации по доступу
  @@index([createdAt])         // Индекс для сортировки по дате создания
}

model UserProfile {
  id              String             @id @default(cuid())
  userId          String             @unique
  user            User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  bio             String?            @db.Text
  phone           String?
  position        String?
  department      String?
  location        String?
  timezone        String?
  skills          String[]           @default([])
  avatarUrl       String?
  coverUrl        String?
  publicEmail     Boolean            @default(false)
  publicPhone     Boolean            @default(false)
  publicBio       Boolean            @default(true)
  publicPosition  Boolean            @default(true)
  publicDepartment Boolean           @default(true)
  publicLocation  Boolean            @default(true)
  publicTimezone  Boolean            @default(true)
  publicSkills    Boolean            @default(true)
  publicLastLogin Boolean            @default(false)
  publicProfileEnabled Boolean       @default(false)
  publicProfileToken   String?       @unique
  visibility      ProfileVisibility  @default(INTERNAL)
  createdAt       DateTime           @default(now())
  updatedAt       DateTime           @updatedAt

  @@index([userId])
}

model UserPreferences {
  id     String @id @default(cuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Тема и локализация
  theme    ThemeMode @default(DARK)
  language String    @default("ru")
  density  UIDensity @default(COMFORTABLE)

  // Анимации
  animations           Boolean @default(true)
  backgroundAnimations Boolean @default(true)
  pageTransitions      Boolean @default(true)
  microInteractions    Boolean @default(true)
  listAnimations       Boolean @default(true)
  modalAnimations      Boolean @default(true)
  scrollAnimations     Boolean @default(true)

  // Фоновые эффекты
  wallpaperStyle     WallpaperStyle @default(AURORA)
  wallpaperIntensity Int            @default(60)
  snowfall           Boolean        @default(false)
  particles          Boolean        @default(false)

  // Уведомления
  soundNotifications  Boolean @default(true)
  desktopNotifications Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
}

enum ThemeMode {
  LIGHT
  DARK
  AUTO
}

enum UIDensity {
  COMPACT
  COMFORTABLE
  SPACIOUS
}

enum WallpaperStyle {
  AURORA
  NEBULA
  GLOW
  COSMIC
}

enum Role {
  SUPERADMIN
  ADMIN
  MANAGER
  AUDITOR
  EMPLOYEE
  VIEWER
}

enum ProfileVisibility {
  INTERNAL
  PRIVATE
}

enum DigestFrequency {
  NONE
  DAILY
  WEEKLY
}

model LoginAudit {
  id        String   @id @default(cuid())
  userId    String?
  user      User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  email     String
  success   Boolean
  reason    String?
  createdAt DateTime @default(now())

  @@index([email, createdAt])
  @@index([userId, createdAt])
}

model UserAudit {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation("UserAuditTarget", fields: [userId], references: [id], onDelete: Cascade)
  actorId   String?
  actor     User?    @relation("UserAuditActor", fields: [actorId], references: [id], onDelete: SetNull)
  action    String
  field     String?
  oldValue  String?  @db.Text
  newValue  String?  @db.Text
  createdAt DateTime @default(now())

  @@index([userId, createdAt])
  @@index([actorId, createdAt])
}

model AdminApproval {
  id            String                @id @default(cuid())
  action        AdminApprovalAction
  status        AdminApprovalStatus   @default(PENDING)
  targetUserId  String
  targetUser    User                  @relation("AdminApprovalTarget", fields: [targetUserId], references: [id], onDelete: Cascade)
  requestedById String
  requestedBy   User                  @relation("AdminApprovalRequestedBy", fields: [requestedById], references: [id], onDelete: Cascade)
  approvedById  String?
  approvedBy    User?                 @relation("AdminApprovalApprovedBy", fields: [approvedById], references: [id], onDelete: SetNull)
  payload       Json?
  createdAt     DateTime              @default(now())
  resolvedAt    DateTime?

  @@index([status, createdAt])
  @@index([targetUserId])
}

enum AdminApprovalAction {
  DEMOTE_ADMIN
  DELETE_ADMIN
}

enum AdminApprovalStatus {
  PENDING
  APPROVED
  REJECTED
}

// ===== ПИСЬМА =====

model Letter {
  id            String       @id @default(cuid())
  number        String       // Номер письма
  org           String       // Организация
  date          DateTime     // Дата письма
  deadlineDate  DateTime     // Дата дедлайна
  status        LetterStatus @default(NOT_REVIEWED)
  type          String?      // Тип запроса
  content       String?      @db.Text // Содержание
  zordoc        String?      // ZorDoc номер
  answer        String?      @db.Text // Ответ
  sendStatus    String?      // Статус отправки
  ijroDate      DateTime?    // Дата исполнения
  comment       String?      @db.Text // Комментарий
  contacts      String?      // Контакты
  applicantName String?
  applicantEmail String?
  applicantPhone String?
  applicantTelegramChatId String?
  applicantAccessToken String? @unique
  applicantAccessTokenExpiresAt DateTime?
  closeDate     DateTime?    // Дата закрытия
  jiraLink      String?      // Ссылка на Jira
  priority      Int          @default(50) // Приоритет (0-100)
  attachmentsFolderId String?

  ownerId       String?
  owner         User?        @relation("OwnerLetters", fields: [ownerId], references: [id])

  files         File[]
  tags          Tag[]
  comments      Comment[]
  watchers      Watcher[]
  favorites     Favorite[]
  history       History[]
  linkedFrom    LinkedLetter[] @relation("LinkedFrom")
  linkedTo      LinkedLetter[] @relation("LinkedTo")
  notifications Notification[]

  // Для синхронизации с Google Sheets
  sheetRowNum   Int?         // Номер строки в Google Sheets
  lastSyncedAt  DateTime?    // Последняя синхронизация

  // Soft delete
  deletedAt     DateTime?    // Дата удаления (null = не удалено)

  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt

  @@index([status])
  @@index([deletedAt])       // Индекс для фильтрации удалённых
  @@index([ownerId])
  @@index([deadlineDate])
  @@index([number])
  @@index([createdAt])
  @@index([closeDate])
  @@index([priority])
  @@index([status, deadlineDate]) // Составной индекс для срочных/просроченных
  @@index([status, ownerId])      // Составной индекс для фильтрации по статусу и ответственному
}

enum LetterStatus {
  NOT_REVIEWED  // не рассмотрен
  ACCEPTED      // принят
  IN_PROGRESS   // взято в работу
  CLARIFICATION // на уточнении
  READY         // готово
  DONE          // сделано
}


enum RequestStatus {
  NEW
  IN_REVIEW
  DONE
  SPAM
  CANCELLED
}

enum RequestPriority {
  LOW
  NORMAL
  HIGH
  URGENT
}

enum RequestCategory {
  CONSULTATION    // Консультация
  TECHNICAL       // Техническая поддержка
  DOCUMENTATION   // Документация
  COMPLAINT       // Жалоба
  SUGGESTION      // Предложение
  OTHER           // Другое
}

enum SlaStatus {
  ON_TIME       // В срок
  AT_RISK       // Под угрозой нарушения
  BREACHED      // Нарушен
}

model Request {
  id              String          @id @default(cuid())
  organization    String
  contactName     String
  contactEmail    String
  contactPhone    String
  contactTelegram String
  description     String          @db.Text
  status          RequestStatus   @default(NEW)
  priority        RequestPriority @default(NORMAL)
  category        RequestCategory @default(OTHER)
  assignedToId    String?
  assignedTo      User?           @relation("RequestAssignee", fields: [assignedToId], references: [id], onDelete: SetNull)
  source          String?
  ipHash          String?

  // SLA fields
  slaDeadline      DateTime?
  firstResponseAt  DateTime?
  resolvedAt       DateTime?
  slaStatus        SlaStatus       @default(ON_TIME)

  // Soft delete
  deletedAt       DateTime?

  files           RequestFile[]
  comments        RequestComment[]
  history         RequestHistory[]
  tags            RequestTag[]

  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  @@index([status, createdAt])
  @@index([assignedToId])
  @@index([priority])
  @@index([category])
  @@index([deletedAt])
  @@index([slaStatus])
  @@index([slaDeadline])
}

model RequestFile {
  id              String              @id @default(cuid())
  name            String
  url             String
  mimeType        String?
  size            Int?
  storageProvider FileStorageProvider @default(LOCAL)
  storagePath     String?
  requestId       String
  request         Request             @relation(fields: [requestId], references: [id], onDelete: Cascade)
  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt

  @@index([requestId])
}

// Комментарии к заявкам
model RequestComment {
  id        String   @id @default(cuid())
  text      String   @db.Text
  requestId String
  request   Request  @relation(fields: [requestId], references: [id], onDelete: Cascade)
  authorId  String
  author    User     @relation("RequestCommentAuthor", fields: [authorId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([requestId, createdAt])
  @@index([authorId])
}

// История изменений заявок
model RequestHistory {
  id        String   @id @default(cuid())
  requestId String
  request   Request  @relation(fields: [requestId], references: [id], onDelete: Cascade)
  userId    String
  user      User     @relation("RequestHistoryActor", fields: [userId], references: [id], onDelete: Cascade)
  field     String   // status, priority, category, assignedTo, etc.
  oldValue  String?  @db.Text
  newValue  String?  @db.Text
  createdAt DateTime @default(now())

  @@index([requestId, createdAt])
  @@index([userId])
}

// Шаблоны ответов для заявок
model RequestResponseTemplate {
  id          String          @id @default(cuid())
  name        String
  content     String          @db.Text
  category    RequestCategory?
  isPublic    Boolean         @default(false)
  createdById String
  createdBy   User            @relation(fields: [createdById], references: [id], onDelete: Cascade)
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt

  @@index([category])
  @@index([createdById])
  @@index([isPublic])
}

// Теги для заявок
model RequestTag {
  id        String    @id @default(cuid())
  name      String    @unique
  color     String    @default("#6B7280")
  requests  Request[]
  createdAt DateTime  @default(now())

  @@index([name])
}

// ===== ФАЙЛЫ =====

model File {
  id        String   @id @default(cuid())
  name      String
  url       String
  driveFileId String?
  storageProvider FileStorageProvider @default(DRIVE)
  storagePath String?
  status    FileStatus @default(READY)
  uploadError String? @db.Text
  syncAttempts Int @default(0)
  lastSyncAttemptAt DateTime?
  mimeType  String?
  size      Int?
  letterId  String
  letter    Letter   @relation(fields: [letterId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status])
}

enum FileStorageProvider {
  DRIVE
  LOCAL
}

enum FileStatus {
  READY
  UPLOADING
  FAILED
  PENDING_SYNC
}

// ===== ТЕГИ =====

model Tag {
  id      String   @id @default(cuid())
  name    String   @unique
  color   String   @default("#6B7280")
  letters Letter[]
}

// ===== КОММЕНТАРИИ (threaded) =====

model Comment {
  id        String    @id @default(cuid())
  text      String    @db.Text
  letterId  String
  letter    Letter    @relation(fields: [letterId], references: [id], onDelete: Cascade)
  authorId  String
  author    User      @relation(fields: [authorId], references: [id])
  parentId  String?
  parent    Comment?  @relation("CommentReplies", fields: [parentId], references: [id])
  replies   Comment[] @relation("CommentReplies")
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  @@index([letterId])
}

// ===== WATCHERS (подписки на письма) =====

model Watcher {
  id               String  @id @default(cuid())
  letterId         String
  letter           Letter  @relation(fields: [letterId], references: [id], onDelete: Cascade)
  userId           String
  user             User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  notifyOnChange   Boolean @default(true)
  notifyOnComment  Boolean @default(true)
  notifyOnDeadline Boolean @default(true)
  createdAt        DateTime @default(now())

  @@unique([letterId, userId])
}

// ===== ИЗБРАННОЕ =====

model Favorite {
  id        String   @id @default(cuid())
  letterId  String
  letter    Letter   @relation(fields: [letterId], references: [id], onDelete: Cascade)
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@unique([letterId, userId])
  @@index([userId])
}

// ===== СВЯЗАННЫЕ ПИСЬМА =====

model LinkedLetter {
  id         String @id @default(cuid())
  fromId     String
  from       Letter @relation("LinkedFrom", fields: [fromId], references: [id], onDelete: Cascade)
  toId       String
  to         Letter @relation("LinkedTo", fields: [toId], references: [id], onDelete: Cascade)
  createdAt  DateTime @default(now())

  @@unique([fromId, toId])
}

// ===== ИСТОРИЯ ИЗМЕНЕНИЙ =====

model History {
  id        String   @id @default(cuid())
  letterId  String
  letter    Letter   @relation(fields: [letterId], references: [id], onDelete: Cascade)
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  field     String   // status, owner, comment, etc.
  oldValue  String?  @db.Text
  newValue  String?  @db.Text
  createdAt DateTime @default(now())

  @@index([letterId])
}

// ===== СИНХРОНИЗАЦИЯ =====

model SyncLog {
  id          String     @id @default(cuid())
  direction   SyncDirection
  status      SyncStatus
  rowsAffected Int       @default(0)
  error       String?    @db.Text
  startedAt   DateTime   @default(now())
  finishedAt  DateTime?
}

// Лог изменений для автоматической синхронизации с Google Sheets
model LetterChangeLog {
  id         String              @id @default(cuid())
  letterId   String
  action     LetterChangeAction
  field      String?             // Какое поле изменилось (null для create/delete)
  oldValue   String?             @db.Text
  newValue   String?             @db.Text
  syncStatus LetterSyncStatus    @default(PENDING)
  syncError  String?             @db.Text
  retryCount Int                 @default(0)
  userId     String?             // Кто сделал изменение
  createdAt  DateTime            @default(now())
  syncedAt   DateTime?           // Когда синхронизировано

  @@index([syncStatus, createdAt])  // Для выборки несинхронизированных
  @@index([letterId])
}

enum LetterChangeAction {
  CREATE
  UPDATE
  DELETE
}

enum LetterSyncStatus {
  PENDING     // Ожидает синхронизации
  PROCESSING  // В процессе
  SYNCED      // Синхронизировано
  FAILED      // Ошибка (будет retry)
  SKIPPED     // Пропущено (дубликат или устарело)
}

enum SyncDirection {
  TO_SHEETS    // Из приложения в Google Sheets
  FROM_SHEETS  // Из Google Sheets в приложение
}

enum SyncStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  FAILED
}

// ===== ШАБЛОНЫ ОТВЕТОВ =====

model AnswerTemplate {
  id          String   @id @default(cuid())
  name        String   // Название шаблона
  content     String   @db.Text // Содержание шаблона
  category    String?  // Категория (необязательно)
  isPublic    Boolean  @default(false) // Доступен всем или только создателю
  createdById String
  createdBy   User     @relation(fields: [createdById], references: [id])
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([createdById])
  @@index([category])
}

// ===== ШАБЛОНЫ ПИСЕМ =====

model LetterTemplate {
  id          String   @id @default(cuid())
  name        String   // Название шаблона
  subject     String?  // Тема письма (опционально)
  body        String   @db.Text // Тело письма
  signature   String?  @db.Text // Подпись (опционально)
  category    String?  // Категория шаблона
  variables   String[] @default([]) // Доступные переменные
  isPublic    Boolean  @default(false) // Публичный или личный
  usageCount  Int      @default(0) // Счётчик использований
  createdById String
  createdBy   User     @relation("LetterTemplateCreator", fields: [createdById], references: [id], onDelete: Cascade)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([category])
  @@index([createdById])
  @@index([isPublic])
  @@index([usageCount])
}

// ===== Notifications =====

model Notification {
  id        String           @id @default(cuid())
  userId    String
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  letterId  String?
  letter    Letter?          @relation(fields: [letterId], references: [id], onDelete: Cascade)
  type      NotificationType
  title     String
  body      String?          @db.Text
  isRead    Boolean          @default(false)
  createdAt DateTime         @default(now())

  @@index([userId, isRead, createdAt])
  @@index([letterId])
}

enum NotificationType {
  COMMENT
  STATUS
  ASSIGNMENT
  SYSTEM
}

// ===== НАСТРОЙКИ РАЗРЕШЕНИЙ =====

model RolePermission {
  id         String   @id @default(cuid())
  role       Role
  permission String   // Permission key (MANAGE_USERS, VIEW_LETTERS, etc.)
  enabled    Boolean  @default(true)
  updatedAt  DateTime @updatedAt
  createdAt  DateTime @default(now())

  @@unique([role, permission])
  @@index([role])
}

// Аудит изменений разрешений
model PermissionAudit {
  id         String   @id @default(cuid())
  role       Role
  permission String
  oldValue   Boolean
  newValue   Boolean
  actorId    String
  createdAt  DateTime @default(now())

  @@index([role, createdAt])
}

// ===== PUSH SUBSCRIPTIONS =====

model PushSubscription {
  id             String    @id @default(cuid())
  userId         String
  user           User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  endpoint       String
  p256dh         String
  auth           String
  expirationTime DateTime?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  @@unique([userId, endpoint])
  @@index([userId])
}
